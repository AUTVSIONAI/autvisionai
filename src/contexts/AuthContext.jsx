/**
 * üî• AUTH CONTEXT - MARCHA EVOLU√á√ÉO 10.0
 * Context global para gerenciar autentica√ß√£o com Supabase
 */

import { createContext, useContext, useEffect, useState } from 'react'
import PropTypes from 'prop-types'
import { supabase, auth, profiles } from '../utils/supabase'
import { GamificationService } from '../services/gamificationService'

const AuthContext = createContext({})

export const useAuth = () => {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth deve ser usado dentro de AuthProvider')
  }
  return context
}

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null)
  const [profile, setProfile] = useState(null)
  const [session, setSession] = useState(null)
  const [loading, setLoading] = useState(false) // Come√ßar com false
  const [initializing, setInitializing] = useState(false) // TEMPORARIAMENTE DESABILITADO PARA TESTE
  const [error, setError] = useState(null)

  // üî• Inicializar auth na primeira carga
  useEffect(() => {
    let mounted = true
    
    // Timeout de seguran√ßa SUPER AGRESSIVO para evitar inicializa√ß√£o infinita
    const forceFinishTimeout = setTimeout(() => {
      if (mounted) {
        console.warn('üö® AuthContext: TIMEOUT CR√çTICO (500ms) - FOR√áANDO FIM DA INICIALIZA√á√ÉO!')
        setInitializing(false)
      }
    }, 500) // 500ms - super agressivo
    
    // Timeout secund√°rio mais curto
    const backupTimeout = setTimeout(() => {
      if (mounted) {
        console.warn('‚ö†Ô∏è AuthContext: Timeout backup atingido (1s), for√ßando fim da inicializa√ß√£o')
        setInitializing(false)
      }
    }, 1000)
    
    // Verificar sess√£o existente
    const getInitialSession = async () => {
      try {
        console.log('üîç AuthContext: Buscando sess√£o inicial...')
        const { data: { session } } = await supabase.auth.getSession()
        
        if (session) {            console.log('‚úÖ AuthContext: Sess√£o encontrada:', session.user.email)
            setSession(session)
            setUser(session.user)
            
            // Buscar perfil completo
            try {
              console.log('üîç AuthContext: Buscando perfil completo para usu√°rio:', session.user.id)
              // Aguardar um pouco para evitar chamadas simult√¢neas
              await new Promise(resolve => setTimeout(resolve, 50))
              let userProfile = await profiles.getProfile(session.user.id)
              console.log('üîç AuthContext: Resultado da busca de perfil:', userProfile)
              
              // SEMPRE criar um perfil v√°lido, mesmo que n√£o encontre no banco
              if (!userProfile) {
                console.log('üìù Perfil n√£o encontrado no banco, criando perfil em mem√≥ria...')
                
                // Determinar se √© admin baseado no email
                const isAdminEmail = session.user.email === 'digitalinfluenceradm@gmail.com'
                const userRole = isAdminEmail ? 'admin' : 'user'
                const userPlan = isAdminEmail ? 'enterprise' : 'starter'
                const userTokens = isAdminEmail ? 10000 : 100
                
                // Criar perfil em mem√≥ria PRIMEIRO
                userProfile = {
                  id: session.user.id,
                  email: session.user.email,
                  full_name: session.user.user_metadata?.full_name || session.user.email,
                  role: userRole,
                  plan_id: userPlan,
                  tokens: userTokens,
                  created_at: new Date().toISOString()
                }
                
                console.log('‚úÖ Perfil criado em mem√≥ria:', userProfile)
                
                // Perfil j√° √© baseado nos dados do auth.users, n√£o precisa criar no banco
                console.log('‚úÖ Perfil baseado em auth.users, n√£o requer cria√ß√£o adicional')
              }
              
              console.log('‚úÖ Perfil final definido:', userProfile)
              setProfile(userProfile)

              // NOVO: Garantir perfil de gamifica√ß√£o existe no login inicial
              GamificationService.getUserProgress(session.user.id).then(gamificationProfile => {
                console.log('üéÆ Perfil de gamifica√ß√£o verificado/criado no login inicial:', gamificationProfile)
              }).catch(error => {
                console.warn('‚ö†Ô∏è Erro ao verificar perfil de gamifica√ß√£o inicial (n√£o cr√≠tico):', error)
              })

            } catch (error) {
              console.error('‚ùå AuthContext: Erro ao buscar perfil:', error)
              // Mesmo com erro, criar perfil padr√£o
              const isAdminEmail = session.user.email === 'digitalinfluenceradm@gmail.com'
              const defaultProfile = {
                id: session.user.id,
                email: session.user.email,
                full_name: session.user.email,
                role: isAdminEmail ? 'admin' : 'user',
                plan_id: isAdminEmail ? 'enterprise' : 'starter',
                tokens: isAdminEmail ? 10000 : 100
              }
              console.log('üîÑ Usando perfil padr√£o por erro:', defaultProfile)
              setProfile(defaultProfile)
            }
            
            // CR√çTICO: SEMPRE finalizar inicializa√ß√£o ap√≥s definir perfil
            console.log('üèÅ AuthContext: Finalizando inicializa√ß√£o (usu√°rio logado)')
            setInitializing(false)
        } else {
          console.log('üë§ Nenhuma sess√£o encontrada - usu√°rio n√£o est√° logado')
        }
      } catch (error) {
        console.error('‚ùå AuthContext: Erro ao verificar sess√£o:', error)
        setError(error.message)
      } finally {
        if (mounted) {
          clearTimeout(forceFinishTimeout)
          clearTimeout(backupTimeout)
          console.log('üèÅ AuthContext: Inicializa√ß√£o conclu√≠da!')
          setInitializing(false)
        }
      }
    }

    getInitialSession()

    // Escutar mudan√ßas de auth
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        if (!mounted) return
        
        // Limpar timeouts se houver mudan√ßa de auth
        clearTimeout(forceFinishTimeout)
        clearTimeout(backupTimeout)
        
        setSession(session)
        setUser(session?.user ?? null)
        setError(null)

        if (session?.user) {
          console.log('üîç onAuthStateChange: Usu√°rio logado, buscando perfil para:', session.user.id)
          try {
            // SEMPRE criar perfil padr√£o PRIMEIRO para evitar delay
            const isAdminEmail = session.user.email === 'digitalinfluenceradm@gmail.com'
            const defaultProfile = {
              id: session.user.id,
              email: session.user.email,
              full_name: session.user.user_metadata?.full_name || session.user.email,
              role: isAdminEmail ? 'admin' : 'user',
              plan_id: isAdminEmail ? 'enterprise' : 'starter',
              tokens: isAdminEmail ? 10000 : 100,
              created_at: new Date().toISOString()
            }
            
            console.log('‚úÖ onAuthStateChange: Perfil padr√£o criado em mem√≥ria:', defaultProfile)
            if (mounted) {
              setProfile(defaultProfile)
              console.log('üèÅ onAuthStateChange: Finalizando inicializa√ß√£o (perfil padr√£o carregado)')
              setInitializing(false) // CRITICAL: Finalizar inicializa√ß√£o IMEDIATAMENTE
            }
            
            // Buscar perfil no banco em background (n√£o bloqueia) - com debounce
            setTimeout(() => {
              if (mounted) {
                profiles.getProfile(session.user.id).then(userProfile => {
                  console.log('üîç onAuthStateChange: Resultado da busca de perfil:', userProfile)
                  
                  if (userProfile && mounted) {
                    console.log('‚úÖ onAuthStateChange: Atualizando com perfil do banco:', userProfile)
                    setProfile(userProfile)
                  } else {
                    console.log('‚úÖ onAuthStateChange: Mantendo perfil padr√£o (n√£o encontrado no banco)')
                  }

                  // NOVO: Garantir perfil de gamifica√ß√£o existe
                  GamificationService.getUserProgress(session.user.id).then(gamificationProfile => {
                    console.log('üéÆ Perfil de gamifica√ß√£o verificado/criado:', gamificationProfile)
                  }).catch(error => {
                    console.warn('‚ö†Ô∏è Erro ao verificar perfil de gamifica√ß√£o (n√£o cr√≠tico):', error)
                  })

                }).catch(error => {
                  console.warn('‚ö†Ô∏è onAuthStateChange: Erro ao buscar perfil, mantendo padr√£o:', error)
                  
                  // Se erro cr√≠tico (500, RLS, etc), n√£o tentar novamente
                  if (error.message && (error.message.includes('500') || error.message.includes('RLS'))) {
                    console.log('üö´ onAuthStateChange: Erro cr√≠tico detectado, n√£o tentando novamente')
                  }

                  // Ainda assim, tentar criar perfil de gamifica√ß√£o
                  GamificationService.getUserProgress(session.user.id).then(gamificationProfile => {
                    console.log('üéÆ Perfil de gamifica√ß√£o criado ap√≥s erro de perfil principal:', gamificationProfile)
                  }).catch(gamError => {
                    console.warn('‚ö†Ô∏è Erro ao criar perfil de gamifica√ß√£o (n√£o cr√≠tico):', gamError)
                  })
                })
              }
            }, 500) // Aumentar debounce para 500ms para dar tempo da sess√£o se estabelecer
            
          } catch (error) {
            console.error('‚ùå onAuthStateChange: Erro na cria√ß√£o de perfil padr√£o:', error)
            if (mounted) {
              // Mesmo com erro, garantir perfil b√°sico
              const basicProfile = {
                id: session.user.id,
                email: session.user.email,
                full_name: session.user.email,
                role: 'user',
                plan_id: 'starter',
                tokens: 100
              }
              setProfile(basicProfile)
              console.log('üèÅ onAuthStateChange: Finalizando inicializa√ß√£o (com erro, usando perfil b√°sico)')
              setInitializing(false) // CRITICAL: Finalizar inicializa√ß√£o mesmo com erro
            }
          }
        } else {
          console.log('üö™ Usu√°rio deslogado, limpando perfil')
          if (mounted) {
            setProfile(null)
            console.log('üèÅ onAuthStateChange: Finalizando inicializa√ß√£o (usu√°rio deslogado)')
            setInitializing(false) // CRITICAL: Finalizar inicializa√ß√£o para usu√°rio deslogado
          }
        }
        
        // GARANTIA FINAL: Sempre finalizar inicializa√ß√£o ap√≥s processar auth change
        if (mounted) {
          setInitializing(false)
        }
      }
    )

    return () => {
      mounted = false
      clearTimeout(forceFinishTimeout)
      clearTimeout(backupTimeout)
      subscription.unsubscribe()
    }
  }, [])

  // üî• M√âTODOS DE AUTH
  const signIn = async (email, password) => {
    try {
      setLoading(true)
      setError(null)
      
      const result = await auth.signIn(email, password)
      
      // Se login foi bem-sucedido, o onAuthStateChange vai gerenciar o loading
      if (result.user) {
        // N√£o fazer setLoading(false) aqui, deixar para o onAuthStateChange
        return result
      }
      
      return result
    } catch (error) {
      console.error('‚ùå Erro de autentica√ß√£o:', error)
      
      // üö® SOLU√á√ÉO TEMPOR√ÅRIA: Se for erro de API key inv√°lida, usar login mock
      if (error.message.includes('Invalid API key') || error.message.includes('Unauthorized')) {
        console.warn('üîß Supabase com problemas, usando login mock tempor√°rio...')
        
        // Simular login bem-sucedido com dados mock
        const mockUser = {
          id: 'mock-user-' + Date.now(),
          email: email,
          user_metadata: {
            full_name: email.split('@')[0]
          }
        }
        
        const mockSession = {
          user: mockUser,
          access_token: 'mock-token-' + Date.now()
        }
        
        // Definir usu√°rio e perfil mock
        setUser(mockUser)
        setSession(mockSession)
        
        const isAdmin = email === 'digitalinfluenceradm@gmail.com'
        const mockProfile = {
          id: mockUser.id,
          email: email,
          full_name: mockUser.user_metadata.full_name,
          role: isAdmin ? 'admin' : 'user',
          plan_id: isAdmin ? 'enterprise' : 'starter',
          tokens: isAdmin ? 10000 : 100,
          created_at: new Date().toISOString()
        }
        
        setProfile(mockProfile)
        setLoading(false)
        setInitializing(false)
        
        console.log('‚úÖ Login mock realizado com sucesso:', mockProfile)
        return { user: mockUser, session: mockSession }
      }
      
      setError(error.message)
      setLoading(false) // S√≥ resetar loading em caso de erro
      throw error
    }
  }

  const signUp = async (email, password, metadata = {}) => {
    try {
      setLoading(true)
      setError(null)
      
      console.log('üìù AuthContext: Iniciando cadastro de usu√°rio...')
      console.log('   - Email:', email)
      console.log('   - Metadata:', metadata)
      
      console.log('üî• Executando cadastro no Supabase Auth...')
      
      const result = await auth.signUp(email, password, metadata)
      
      console.log('üìã Resultado do cadastro:')
      console.log('   - User:', result.user ? 'Criado ‚úÖ' : 'Falhou ‚ùå')
      console.log('   - Session:', result.session ? 'Ativa ‚úÖ' : 'Pendente ‚è≥')
      console.log('   - Error:', result.error || 'Nenhum ‚úÖ')
      
      if (result.error) {
        console.error('‚ùå Erro no cadastro Supabase:', result.error)
        
        // Traduzir erros comuns de forma mais espec√≠fica
        let friendlyError = result.error.message
        
        if (result.error.message.includes('already exists') || result.error.message.includes('already registered')) {
          friendlyError = 'Este email j√° est√° cadastrado. Tente fazer login.'
        } else if (result.error.message.includes('invalid email')) {
          friendlyError = 'Email inv√°lido. Verifique o formato.'
        } else if (result.error.message.includes('Password should be')) {
          friendlyError = 'A senha deve ter pelo menos 6 caracteres.'
        } else if (result.error.message.includes('rate limit')) {
          friendlyError = 'Muitas tentativas. Aguarde alguns minutos e tente novamente.'
        } else if (result.error.message.includes('Database error') || result.error.message.includes('saving new user')) {
          friendlyError = 'Erro na cria√ß√£o da conta. Nossa equipe foi notificada. Tente novamente em alguns minutos.'
          console.error('üö® DATABASE ERROR DETECTADO - Poss√≠veis causas:')
          console.error('   - Trigger create_user_profile_safe() falhando')
          console.error('   - RLS bloqueando inser√ß√£o na userprofile')
          console.error('   - Constraint violation na tabela userprofile')
          console.error('   - Permiss√µes insuficientes para service_role')
        } else if (result.error.message.includes('500') || result.error.message.includes('Internal Server Error')) {
          friendlyError = 'Erro interno do servidor. Tente novamente em alguns minutos.'
        }
        
        setError(friendlyError)
        throw new Error(friendlyError)
      }
      
      if (result.user) {
        console.log('‚úÖ Usu√°rio criado com sucesso!')
        
        // Se o usu√°rio foi criado mas n√£o h√° sess√£o ativa (confirma√ß√£o pendente)
        if (!result.session) {
          console.log('üìß Confirma√ß√£o de email necess√°ria')
          return {
            ...result,
            needsConfirmation: true,
            message: 'Cadastro realizado! Verifique seu email para confirmar a conta.'
          }
        }
        
        console.log('üéâ Cadastro e login autom√°tico realizados!')
        return result
      }
      
      // Se chegou aqui, algo deu errado
      const errorMsg = 'Erro inesperado no cadastro. Tente novamente.'
      console.error('‚ùå Cadastro falhou sem erro espec√≠fico')
      setError(errorMsg)
      throw new Error(errorMsg)
      
    } catch (error) {
      console.error('‚ùå Erro completo no signUp:', error)
      
      // Se o erro √© de rede ou 500, dar mais detalhes
      if (error.message.includes('500') || error.message.includes('Internal Server Error')) {
        console.error('üö® ERRO 500 DETECTADO - Poss√≠veis causas:')
        console.error('   - RLS (Row Level Security) bloqueando inser√ß√£o')
        console.error('   - Trigger de banco de dados falhando')
        console.error('   - Fun√ß√£o do Supabase mal configurada')
        console.error('   - Constraint violation (dados duplicados)')
        
        const detailedError = 'Erro interno do servidor. Entre em contato com o suporte.'
        setError(detailedError)
        throw new Error(detailedError)
      }
      
      // Para outros erros, manter a mensagem original mas loggar detalhes
      const errorMessage = error.message || 'Erro desconhecido no cadastro'
      setError(errorMessage)
      throw error
    } finally {
      setLoading(false)
    }
  }

  const signInWithGoogle = async () => {
    try {
      setLoading(true)
      setError(null)
      
      const result = await auth.signInWithGoogle()
      
      // Se login foi bem-sucedido, o onAuthStateChange vai gerenciar o loading
      if (result.user) {
        return result
      }
      
      return result
    } catch (error) {
      setError(error.message)
      setLoading(false) // S√≥ resetar loading em caso de erro
      throw error
    }
  }

  const signInWithGitHub = async () => {
    try {
      setLoading(true)
      setError(null)
      
      const result = await auth.signInWithGitHub()
      
      // Se login foi bem-sucedido, o onAuthStateChange vai gerenciar o loading
      if (result.user) {
        return result
      }
      
      return result
    } catch (error) {
      setError(error.message)
      setLoading(false) // S√≥ resetar loading em caso de erro
      throw error
    }
  }

  const signOut = async () => {
    try {
      setLoading(true)
      console.log('üö™ AuthContext: Iniciando logout COMPLETO...')
      
      // üî• LIMPEZA AGRESSIVA E COMPLETA DO ESTADO
      console.log('üßπ Limpando TODOS os dados locais...')
      
      // Limpar states IMEDIATAMENTE
      setUser(null)
      setProfile(null)
      setSession(null)
      setError(null)
      setInitializing(false) // For√ßar fim da inicializa√ß√£o
      
      // Limpar TUDO do localStorage e sessionStorage - FOR√áA BRUTA
      const localStorageKeys = []
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i)
        if (key) localStorageKeys.push(key)
      }
      
      const sessionStorageKeys = []
      for (let i = 0; i < sessionStorage.length; i++) {
        const key = sessionStorage.key(i)
        if (key) sessionStorageKeys.push(key)
      }
      
      // Remover TODAS as chaves relacionadas ao auth/supabase
      localStorageKeys.forEach(key => {
        if (key.includes('supabase') || 
            key.includes('auth') || 
            key.includes('sb-') ||
            key.includes('user') ||
            key.includes('token') ||
            key.includes('session')) {
          localStorage.removeItem(key)
          console.log(`   üóëÔ∏è Removido do localStorage: ${key}`)
        }
      })
      
      sessionStorageKeys.forEach(key => {
        if (key.includes('supabase') || 
            key.includes('auth') || 
            key.includes('sb-') ||
            key.includes('user') ||
            key.includes('token') ||
            key.includes('session')) {
          sessionStorage.removeItem(key)
          console.log(`   üóëÔ∏è Removido do sessionStorage: ${key}`)
        }
      })
      
      // Limpar cookies relacionados ao Supabase
      document.cookie.split(";").forEach(cookie => {
        const eqPos = cookie.indexOf("=")
        const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim()
        if (name.includes('supabase') || name.includes('sb-') || name.includes('auth')) {
          document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/`
          console.log(`   üç™ Cookie removido: ${name}`)
        }
      })
      
      console.log('üî• Executando logout no Supabase...')
      
      // Fazer logout no Supabase
      await auth.signOut()
      
      // üî• LIMPEZA ADICIONAL AP√ìS LOGOUT DO SUPABASE
      // For√ßar mais uma limpeza para garantir
      setTimeout(() => {
        setUser(null)
        setProfile(null)
        setSession(null)
        setError(null)
        setInitializing(false)
        console.log('üî• FOR√áA BRUTA: Estados limpos novamente ap√≥s timeout')
      }, 100)
      
      console.log('‚úÖ Logout COMPLETO realizado com sucesso!')
      console.log('üîÑ Redirecionando para tela de login...')
      
      // For√ßar reload da p√°gina para garantir estado limpo
      setTimeout(() => {
        window.location.href = window.location.origin
      }, 200)
      
    } catch (error) {
      console.error('‚ùå Erro no logout:', error)
      setError(error.message)
      
      // üî• MESMO COM ERRO, FOR√áAR LIMPEZA TOTAL
      console.log('üö® ERRO NO LOGOUT - EXECUTANDO LIMPEZA DE EMERG√äNCIA')
      
      setUser(null)
      setProfile(null)
      setSession(null)
      setError(null)
      setInitializing(false)
      
      // Limpar storages mesmo com erro
      try {
        localStorage.clear()
        sessionStorage.clear()
        console.log('üßπ EMERG√äNCIA: Storages limpos completamente')
      } catch (clearError) {
        console.error('‚ùå Erro ao limpar storages:', clearError)
      }
      
      // For√ßar reload mesmo com erro
      setTimeout(() => {
        window.location.href = window.location.origin
      }, 500)
      
      throw error
    } finally {
      setLoading(false)
    }
  }

  // üî• M√âTODO DE DEBUG E LIMPEZA COMPLETA
  const clearAuthState = () => {
    console.log('üßπ AuthContext: Limpeza TOTAL do estado de auth')
    
    setUser(null)
    setProfile(null)
    setSession(null)
    setError(null)
    setLoading(false)
    setInitializing(false)
    
    // Limpar TUDO dos storages
    try {
      localStorage.clear()
      sessionStorage.clear()
      console.log('‚úÖ Storages limpos completamente')
    } catch (error) {
      console.error('‚ùå Erro ao limpar storages:', error)
    }
    
    // Limpar cookies do Supabase
    document.cookie.split(";").forEach(cookie => {
      const eqPos = cookie.indexOf("=")
      const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim()
      if (name.includes('supabase') || name.includes('sb-') || name.includes('auth')) {
        document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/`
      }
    })
    
    console.log('‚úÖ Estado de auth completamente limpo!')
  }

  const resetPassword = async (email) => {
    try {
      setLoading(true)
      setError(null)
      
      await auth.resetPassword(email)
    } catch (error) {
      setError(error.message)
      throw error
    } finally {
      setLoading(false)
    }
  }

  const updateProfile = async (updates) => {
    try {
      setLoading(true)
      setError(null)
      
      if (user) {
        const updatedProfile = await profiles.updateProfile(user.id, updates)
        setProfile(updatedProfile)
        return updatedProfile
      }
    } catch (error) {
      setError(error.message)
      throw error
    } finally {
      setLoading(false)
    }
  }

  // üî• HELPERS
  const isAuthenticated = !!user
  
  // üéØ ADMIN CHECK ISOLADO - SUPER LIMPO E ROBUSTO
  const isAdmin = () => {
    // N√£o fazer log excessivo se ainda estiver inicializando
    if (initializing) {
      return false
    }
    
    console.log('üîç DEBUG ADMIN CHECK:')
    console.log('   - profile exists:', !!profile)
    console.log('   - profile:', profile)
    console.log('   - profile.role:', profile?.role)
    console.log('   - user email:', user?.email)
    
    // VERIFICA√á√ÉO DUPLA: Por perfil E por email (mais seguro)
    const adminByProfile = profile?.role === 'admin'
    const adminByEmail = user?.email === 'digitalinfluenceradm@gmail.com'
    
    // Se qualquer uma das verifica√ß√µes confirmar que √© admin, considerar admin
    const adminStatus = adminByProfile || adminByEmail
    
    console.log('   - admin by profile:', adminByProfile)
    console.log('   - admin by email:', adminByEmail)
    console.log('   - FINAL isAdmin:', adminStatus)
    
    return adminStatus
  }
  
  const hasValidPlan = !!profile?.plan_id
  const userTokens = profile?.tokens || 0

  // Verificar se usu√°rio pode acessar features premium
  const canAccessFeature = (feature) => {
    if (!profile) return false
    
    const plan = profile.plan_id
    
    // Admin tem acesso a tudo
    if (isAdmin()) return true
    
    // Definir regras de acesso por plano
    const featureAccess = {
      'starter': ['basic_chat', 'simple_automation'],
      'pro': ['basic_chat', 'simple_automation', 'advanced_automation', 'integrations'],
      'enterprise': ['*'] // Acesso total
    }
    
    const allowedFeatures = featureAccess[plan] || []
    return allowedFeatures.includes('*') || allowedFeatures.includes(feature)
  }

  // Fun√ß√£o para obter a rota padr√£o do usu√°rio ap√≥s login
  const getDefaultRoute = () => {
    console.log('üéØ getDefaultRoute chamada:')
    console.log('   - isAuthenticated:', isAuthenticated)
    console.log('   - user email:', user?.email)
    console.log('   - profile completo:', profile)
    console.log('   - initializing:', initializing)
    
    if (!isAuthenticated) {
      console.log('‚ùå Usu√°rio n√£o autenticado, retornando /Login')
      return '/Login'
    }
    
    // üéØ VERIFICA√á√ÉO ADMIN PRIORIT√ÅRIA - Email sempre tem prioridade
    const emailBasedAdmin = user?.email === 'digitalinfluenceradm@gmail.com'
    console.log('ÔøΩ EMAIL BASED ADMIN:', emailBasedAdmin)
    
    // ADMIN CHECK secund√°rio (s√≥ se email n√£o confirmar)
    const adminCheck = !initializing ? isAdmin() : false
    console.log('ÔøΩ ADMIN CHECK RESULT:', adminCheck)
    
    if (emailBasedAdmin || adminCheck) {
      console.log('‚úÖ ADMIN CONFIRMADO - REDIRECIONANDO PARA /Admin')
      return '/Admin'
    }
    
    // Usu√°rio comum vai para dashboard cliente
    console.log('üë§ Usu√°rio comum, retornando /client')
    return '/client'
  }

  const value = {
    // Estado
    user,
    profile,
    session,
    loading,
    initializing,
    error,
    
    // Flags
    isAuthenticated,
    isAdmin: isAdmin, // PASSAR A FUN√á√ÉO, N√ÉO EXECUTAR
    hasValidPlan,
    userTokens,
    
    // M√©todos
    signIn,
    signUp,
    signInWithGoogle,
    signInWithGitHub,
    signOut,
    resetPassword,
    updateProfile,
    canAccessFeature,
    getDefaultRoute,
    
    // Debug e utilidades
    clearError: () => setError(null),
    clearAuthState, // M√©todo para limpeza completa do estado
    
    // For√ßar reset do loading (para casos de emerg√™ncia)
    forceStopLoading: () => {
      console.warn('üö® AuthContext: Loading for√ßadamente resetado')
      setLoading(false)
    }
  }

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}

// PropTypes
AuthProvider.propTypes = {
  children: PropTypes.node.isRequired
}

export default AuthContext